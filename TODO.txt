- Implement distribute message (DONE)
    - Implement dest visited (DONE)
    - Implement chunks functions (DONE)
- Implement cache_manager (DONE)
    - Make sure cache file name includes timestamp (DONE)
- Implement file_manager 
    - Implement file download (both file and media/no path files) (DONE)
    - Implement caching behaviour (DONE)
    - Implement send file/media (DONE)
- Implement promised_chunks (DONE)
    - Implement handle_chunk (DONE)
    - Implement send_chunk (DONE)
- Implement chunks_missing (DONE)
- Implement file_request (DONE)
    - Implement if already have media/temp_file, copy (don't go through sendFile) (DONE)
- Implement store manager (DONE)
- Implement rest of sync server commands (DONE)
- Implement all core functions / add template (DONE)
- ALL CLEAN FUNCTIONS / todo!() (DONE)
    - Make sure to check browser implementation for extra steps (DONE)
- Implement rest of pool_client (DONE)
    - Implement UI bindings / Message bindings (DONE)
    - Implement Events (including event updates i.e for file download) (DONE)
    - Implement complete download U.I + Event (DONE)
- TEST
    - Test update latest (DONE)
    - Test file offers between 2 nodes (DONE)
    - Test caching (DONE)
    - Test multiple dest send (DONE)
    - Test chunks missing / chunks promised (DONE)
    - Test caching while receiving (DONE)
    - Test multiple nodes (DONE)
    - Test multiple nodes with child nodes (DONE)
    - Test multiple files at same time (DONE)
    - Test removal nodes while sending (DONE)
        - Without chunksMissing (DONE)
        - With chunksMissing (DONE)
    - Test image (DONE)
        - Process image async (DONE)
        - Deleted image render (DONE)
    - Test temp files logic
        - Implement Customer URI protocol (DONE)
        - Test temp files overflow (DONE)
    - Test max cache behaviour (DONE)
        - Test without read (DONE)
        - Test with read (THEORY TESTING)
    - Test DC connecting leak system (DONE)
- Implement message saving (DONE)
    - Implement pagination (DONE)
    - Implement go to latest (DONE)
- Implement authentication system (DONE)
    - Implement device link
- Implement pool manager
    - Implement pool manager logic
        - PoolID are used (along with prefix like pool:{POOL_ID})
        - Creating a new pool is unbounded for now
        - Joining a pool requires poolID (use like >= 11 nanoIDLen)
        - A request must be made
            - The requester has a disabled/offline pool U.I view
              to indicate requested pools
            - Anyone in pool can accept request indicated in the
              requests tab (make new tab)
        - Cancel request can be made
        - Leave pool
    - Implement U.I
        - One for all search bar
            - Search bar configured to allow multiple types
              of search
                - e.g my pools/requested pools/actions like
                  to request new pools/users (future)/ etc.
    - Implement Request feed for each pool
        - For pool for own devices, the request feed
          would be to link new devices!
- Implement sync_server saving data using db engine
    - https://github.com/akrylysov/pogreb (KV fast reads) (CURRENT CHOICE)
    - https://git.mills.io/prologic/bitcask-bench (for other choices)
    - NOTE:
        - Should not store any configuration
        - Should ONLY store devices and id's which is attathched to the user identity
        - So in theory, ONLY the authentication system stores anything
        - Configurations will be synced through their devices
        - BUT actual pools need to be stored/the users in them
            - But this should be lightweight and things like display name
              should be managed IN the pool
            - That being said there should be a good indicator on identification
                - show ID on hover
                - profile pictures
                - etc.
            - BUT user data such as "what pools i'm subscribed to" should be within device
- Implement a device to device pool / sync data
    - This interface/pool will be dedicated to device data syncing
    - A sync folder 
        - Can use on any pool. Offer a sync update?
        - BAiscally like file offers but grouped update
        - OR just a folder funcitonality that is checked every time
          boot up and automatically sends the offer for new appearing files
        - OR one just big shared sync folder
            - All the diff happen on own node side 
            - All files have attatched owners
            - Only owner can remove their offer in big sync folder
        - Maybe just implement that functionality to all folders?
            - It should be a special tab though
            - Folders can be on a sepearte tab and individual file should be
              treated as individual file offers (i.e the file offers tab)
        - Ok there should be no single SYNC feature 
            - You already have tabs for every single available files
            - Use that and provide features like "download all" or download missing
            - Have indicator of which files you already have?
            - Or even just do it for folders
            - Or even make the whole thing a folder, distributed network style
        - Or an AUTOSYNC feature
            - Choose folders to auto sync or the whole pool
- Folder support
- Indicator for uploading (small indicator on the file tab?)
- Offline access
- Notifications
- NAT checks
- SSL
- Mobile
- Moderation

- Desktop app and mobile app (IMPORTANT!)
    - Try to have some documentation for the more difficult to understand parts!
    - For SORT functions, use insertion sort for <= 10 elements
        - Also insertion sort is good for ALMOST sorted arrays...
        - which is very applicable to this sort of application
    - Require good decoupling
        - UI, Disk Manager, Pool Client, Communication
        - Such that either or can be replaced
    - Use Tauri? (Allow for rust core and reactjs ui)
        - Well DOCUMENTED
        - BENCHMARK ALL THE BELOW (also helps with practicing rust)
        - Problem is webrtc-rs performance is bad
        - Can use libp2p (QUIC, though tcp seems to perform better)
            - Traditional hole punching not supported so no.
        - Can build own hole punching with raw TCP/UDP
            - See how libp2p does it
        - https://github.com/lerouxrgd/datachannel-rs
            - rust bindings to c++ libdatachannel and no overhead
            - still have to test vs tcp hole punching
        - PION is very fast, but no bindings
    - For file reading, at 64kb, shouldn't be too much impact on reading bigger chunks
    - USE tcp/udp hole punching?
        - OR find better webrtc datachannel implementation and use that...
        - You don't need wasm if it's an application, just bind GUI
    - Use gRPC for rpcs
    - Rewrite cache logic
    - Store messages on phone (only messages that the devices was there for)
        - Add get more from devices features and add messaging caching feature
    - Devices data sync (using device pool)
    - STORE BY CREATED (also in messages, so that merge/download history will be easier)
    - DOWNLOAD HISTORY
    - Store fileOffers / filePath
    - Add folder support
    - Allow copy image / drag and drop
    - Automatic connection between devices on home screen (defaul pool)
    - Report nodes system
        - Verify identity of message (relative to src node using public private keys)
            - This is why chunksMissing shouldn't have promisedChunks
                - Should be at least one way to garauntee the request going through
                - promisedChunks is just a one time optimization trick taht will work if all nodes are compliant
            - Also implement a system to check that nodes are actually sending messages
                - What happens if a request never gets a reply, how do we know which node to blame
        - Credibility score system (research)
- Authetication System
    - Webauthn
        - Private key should be securely stored on user device
            - Maybe even password/pin/biometrics/authenticator protected!
            - Not necessarily password, but something that the device has (like PIN) and connect it to there
                - navigate.credentials but not on browser
        - Multiple devices that want to register under one user must link from any other device
            - Via authenticator apps?
            - Via physical authenticator?
            - Point is it needs some connecting device to validate
            - There needs to be a default way of doing it without using 3rd party authenticators
                - Do webauthn flow on any device, except instead of the registered device sending
                  the encrypted code back, transfer the TEMPORARY code (using QR code?) to new device
                  and the new device registers WITH that TEMPORARY code to verify it is a user 
        - Temporary logins
            - It would just be the same exact thing as adding a device
            - The only thing "temporary" is that you can delete the device
            - You could even set a timelimit feature or smth
- Build a small database for sync-server for any important information
    - RocksDB 
- Clustered-sync-servers with RAFT
    - If open sourced, you need to be able to have high availability (as an option)
    - Built in STUN server
    - Pebble for DB engine
        - Sync-server for some pool should be available 3 times
        - The database will be connected with these servers
            - So if all 3 sync servers go down, no data/service will be available
    - RATE LIMIT
- Multiple pools/User profile
- DeviceType / device name differentiation in messagesView
- Streaming, using architecture with node in the center
    - Allowing creators to issue their own servers control their own content
    - They become the central node outputting to 9 nodes
        - Assuming an upload requires 10mb/s, that's 90 mb/s!
            - That's a problem
        - Possibly only outputting to 3 nodes and but quickly switching when
        node fails?
    - Their own servers handle authorization via monetization
    - REQUIRES GOOD RELIABILITY AND REPORT SERVICE

- Slowly transition from web 2.0 to web 3.0
    - Possibly to start with a cluster of sync-servers with RAFT for data sync
- BUILD AROUND web 3.0 (own servers/auth system)
    - Use webauthn + biometrics (try not to use phone numbers)
    - Allow sync server instances
    - No need for databases
        - Databases are made of your devices!
    - Blockchain for identification? (NO GAS)
    - Decentralized notification system!
        - Running your own notification instance, so sync-servers can connect to you
        - Push notifications

- PROXIMITY CHAT IRL:
    - AirDrop

BRAINSTORM NOTES:

- Build won auth system (avoid lock in)
- CoackroachDB
    - This should be a good choice given authentication nature
- Custom NewSQL on rocksDB (rust or c++)

- NOTIFICATIONS
    - NOT dedicated, they are just optional tags to add if you want to notify people of your message
    - Should not break the concept of "Data being stored on server/going through server unless specified"
- Finish designing rest of login/profile/intro page
- SHOULD ONLY BE ABLE TO CONNECT TO ONE POOL AT A TIME
    - Automatic connects/disconnects

- Possible missed messages (true if some node has logged on since last)
- Broadcasting live media but only one track? 
    - Consider what useful applications this could have. Broadcasting?
- Whispers
    - end to end encrypted?
- Save messages
- Retract messages
    - Delete downloads/retry
- Announcements
- Auth + Device management

- Folder. Tar in webworker
- Store fileOffer/fileID/file/whatever
    - Check if file still exists when starting AND when starting to send/remove fileoffer
    - ONLY FOR APPS (MOBILE | DESKTOP, NOT SITE)
- Performance tests
- Device performance requirements (including nat traversal consideration, encoding/decoding, and internet speed)
- Add Folder support Drag and Drop (Tarring, but performance could suffer)
- Integrate rest of reports
    - Mostly fraud detection
    - Report should count retries (3 times and you're out type deal)
- Security for important messages (possibly involving a majority rule)
- Hash verification for files
    - How to overcome checksum security/hashing time
    - Either mapreduce it, OR have an option to have extra verification process (extra X time to download/upload)
- Interactive board/white board etc. (send in chunks, when user lifts off)

- Test broadcasting live media (mainly audio + pictures as video is just simply too big for upload)
    - Not that it isn't possible, but there are serious performance impacts to be considered
    - addTrack requires renegotiation, and if we add a track for every node, it will be costly on every aspect
    - An MCU/SFU is also bad becuase it will be impossible to filter own node media when data eventually reaches to them