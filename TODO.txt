- Implement distribute message (DONE)
    - Implement dest visited (DONE)
    - Implement chunks functions (DONE)
- Implement cache_manager (DONE)
    - Make sure cache file name includes timestamp (DONE)
- Implement file_manager 
    - Implement file download (both file and media/no path files) (DONE)
    - Implement caching behaviour (DONE)
    - Implement send file/media (DONE)
- Implement promised_chunks (DONE)
    - Implement handle_chunk (DONE)
    - Implement send_chunk (DONE)
- Implement chunks_missing (DONE)
- Implement file_request (DONE)
    - Implement if already have media/temp_file, copy (don't go through sendFile) (DONE)
- Implement store manager (DONE)
    - Enable fs https://tauri.app/v1/api/js/fs/
    - Store manager seperate from events maybe
    - File offers should be stored in store
    - Store should be stored in JSON format
    - Keep different json files to avoid rewriting a bunch
        - i.e user info / config content / file offers / etc.
    - Periodic state event updates (mainly for file download)
    - SINCE temp files are also file offers, store as well
    - Store manager should have a function to create a cached version
        - And use this cache to be stored in pool_state
        - This way we don't have to go throuhg arcswap for user_id / device_id
- Implement rest of sync server commands (DONE)
- Implement all core functions / add template
- ALL CLEAN FUNCTIONS / todo!()
    - Make sure to check browser implementation for extra steps
- Implement rest of pool_client
    - Implement UI bindings / Message bindings
    - Implement Events (including event updates i.e for file download)
    - Implement complete download U.I + Event
        - When download completes, user will see on the bar that downloads
          have completed. When they click, it opens file dialog to that path
    - https://tauri.app/v1/guides/features/command#async-commands
        - Nvm, it is not executed on main thread, so no worries
- TEST
- Implement message saving
    - Implement load init messages to received_queue
- Implement authentication system
    - Only one user should be active per device
    - Could change in future?
    - PASSKEYS
        - Except maybe custom authenticator?
        - No need to install an extra app
- Implement sync_server saving data using db engine
    - https://github.com/akrylysov/pogreb (KV fast reads) (CURRENT CHOICE)
    - https://git.mills.io/prologic/bitcask-bench (for other choices)
    - NOTE:
        - Should not store any configuration
        - Should ONLY store devices and id's which is attathched to the user identity
        - So in theory, ONLY the authentication system stores anything
        - Configurations will be synced through their devices
        - BUT actual pools need to be stored/the users in them
            - But this should be lightweight and things like display name
              should be managed IN the pool
            - That being said there should be a good indicator on identification
                - show ID on hover
                - profile pictures
                - etc.
            - BUT user data such as "what pools i'm subscribed to" should be within device
- Implement a device to device pool / sync data
    - This interface/pool will be dedicated to device data syncing

- Desktop app and mobile app (IMPORTANT!)
    - Try to have some documentation for the more difficult to understand parts!
    - For SORT functions, use insertion sort for <= 10 elements
        - Also insertion sort is good for ALMOST sorted arrays...
        - which is very applicable to this sort of application
    - Require good decoupling
        - UI, Disk Manager, Pool Client, Communication
        - Such that either or can be replaced
    - Use Tauri? (Allow for rust core and reactjs ui)
        - Well DOCUMENTED
        - BENCHMARK ALL THE BELOW (also helps with practicing rust)
        - Problem is webrtc-rs performance is bad
        - Can use libp2p (QUIC, though tcp seems to perform better)
            - Traditional hole punching not supported so no.
        - Can build own hole punching with raw TCP/UDP
            - See how libp2p does it
        - https://github.com/lerouxrgd/datachannel-rs
            - rust bindings to c++ libdatachannel and no overhead
            - still have to test vs tcp hole punching
        - PION is very fast, but no bindings
    - For file reading, at 64kb, shouldn't be too much impact on reading bigger chunks
    - USE tcp/udp hole punching?
        - OR find better webrtc datachannel implementation and use that...
        - You don't need wasm if it's an application, just bind GUI
    - Use gRPC for rpcs
    - Rewrite cache logic
    - Store messages on phone (only messages that the devices was there for)
        - Add get more from devices features and add messaging caching feature
    - Devices data sync (using device pool)
    - STORE BY CREATED (also in messages, so that merge/download history will be easier)
    - DOWNLOAD HISTORY
    - Store fileOffers / filePath
    - Add folder support
    - Allow copy image / drag and drop
    - Automatic connection between devices on home screen (defaul pool)
    - Report nodes system
        - Verify identity of message (relative to src node using public private keys)
            - This is why chunksMissing shouldn't have promisedChunks
                - Should be at least one way to garauntee the request going through
                - promisedChunks is just a one time optimization trick taht will work if all nodes are compliant
            - Also implement a system to check that nodes are actually sending messages
                - What happens if a request never gets a reply, how do we know which node to blame
        - Credibility score system (research)
- Authetication System
    - Webauthn
        - Private key should be securely stored on user device
            - Maybe even password/pin/biometrics/authenticator protected!
            - Not necessarily password, but something that the device has (like PIN) and connect it to there
                - navigate.credentials but not on browser
        - Multiple devices that want to register under one user must link from any other device
            - Via authenticator apps?
            - Via physical authenticator?
            - Point is it needs some connecting device to validate
            - There needs to be a default way of doing it without using 3rd party authenticators
                - Do webauthn flow on any device, except instead of the registered device sending
                  the encrypted code back, transfer the TEMPORARY code (using QR code?) to new device
                  and the new device registers WITH that TEMPORARY code to verify it is a user 
        - Temporary logins
            - It would just be the same exact thing as adding a device
            - The only thing "temporary" is that you can delete the device
            - You could even set a timelimit feature or smth
- Build a small database for sync-server for any important information
    - RocksDB 
- Clustered-sync-servers with RAFT
    - If open sourced, you need to be able to have high availability (as an option)
    - Built in STUN server
    - Pebble for DB engine
        - Sync-server for some pool should be available 3 times
        - The database will be connected with these servers
            - So if all 3 sync servers go down, no data/service will be available
    - RATE LIMIT
- Multiple pools/User profile
- DeviceType / device name differentiation in messagesView
- Streaming, using architecture with node in the center
    - Allowing creators to issue their own servers control their own content
    - They become the central node outputting to 9 nodes
        - Assuming an upload requires 10mb/s, that's 90 mb/s!
            - That's a problem
        - Possibly only outputting to 3 nodes and but quickly switching when
        node fails?
    - Their own servers handle authorization via monetization
    - REQUIRES GOOD RELIABILITY AND REPORT SERVICE

- Slowly transition from web 2.0 to web 3.0
    - Possibly to start with a cluster of sync-servers with RAFT for data sync
- BUILD AROUND web 3.0 (own servers/auth system)
    - Use webauthn + biometrics (try not to use phone numbers)
    - Allow sync server instances
    - No need for databases
        - Databases are made of your devices!
    - Blockchain for identification? (NO GAS)
    - Decentralized notification system!
        - Running your own notification instance, so sync-servers can connect to you
        - Push notifications

- PROXIMITY CHAT IRL:
    - AirDrop

BRAINSTORM NOTES:

- Build won auth system (avoid lock in)
- CoackroachDB
    - This should be a good choice given authentication nature
- Custom NewSQL on rocksDB (rust or c++)

- NOTIFICATIONS
    - NOT dedicated, they are just optional tags to add if you want to notify people of your message
    - Should not break the concept of "Data being stored on server/going through server unless specified"
- Finish designing rest of login/profile/intro page
- SHOULD ONLY BE ABLE TO CONNECT TO ONE POOL AT A TIME
    - Automatic connects/disconnects

- Possible missed messages (true if some node has logged on since last)
- Broadcasting live media but only one track? 
    - Consider what useful applications this could have. Broadcasting?
- Whispers
    - end to end encrypted?
- Save messages
- Retract messages
    - Delete downloads/retry
- Announcements
- Auth + Device management

- Folder. Tar in webworker
- Store fileOffer/fileID/file/whatever
    - Check if file still exists when starting AND when starting to send/remove fileoffer
    - ONLY FOR APPS (MOBILE | DESKTOP, NOT SITE)
- Performance tests
- Device performance requirements (including nat traversal consideration, encoding/decoding, and internet speed)
- Add Folder support Drag and Drop (Tarring, but performance could suffer)
- Integrate rest of reports
    - Mostly fraud detection
    - Report should count retries (3 times and you're out type deal)
- Security for important messages (possibly involving a majority rule)
- Hash verification for files
    - How to overcome checksum security/hashing time
    - Either mapreduce it, OR have an option to have extra verification process (extra X time to download/upload)
- Interactive board/white board etc. (send in chunks, when user lifts off)

- Test broadcasting live media (mainly audio + pictures as video is just simply too big for upload)
    - Not that it isn't possible, but there are serious performance impacts to be considered
    - addTrack requires renegotiation, and if we add a track for every node, it will be costly on every aspect
    - An MCU/SFU is also bad becuase it will be impossible to filter own node media when data eventually reaches to them